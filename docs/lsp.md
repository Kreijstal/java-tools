# LSP Integration Guide

This document explains how the JVM tools expose Language Server Protocol (LSP) features and how an editor or external client can integrate with them. The server follows the standard [Language Server Protocol](https://microsoft.github.io/language-server-protocol/specification) over JSON-RPC 2.0, reuses the same analysis/assembly stack as the CLI + MCP tools (dead-code diagnostics, refactors, workspace queries), and ships as a plain Node.js script with no bundling required.

The canonical implementation lives in `scripts/lsp-server.js` and shares code with the in-process harness (`src/lsp/inProcessHarness.js`) that our unit tests use. This guide covers the transport, protocol surface, and roadmap so client authors can wire up editors confidently.

## Transport & Lifecycle

- **Entry point:** `node scripts/lsp-server.js`
- **Transport:** stdio with `Content-Length` headers (standard LSP framing).
- **Initialization:** send the standard `initialize` request followed by `initialized`. Include configuration under `initializationOptions` if needed (see below).
- **Shutdown:** use `shutdown` and `exit`.

Example initialization request:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "clientInfo": { "name": "MyEditor" },
    "rootUri": "file:///home/user/project",
    "initializationOptions": {
      "classpath": ["sources", "examples"],
      "jvmCliPath": "scripts/jvm-cli.js"
    },
    "capabilities": {
      "textDocument": {
        "synchronization": { "willSave": false },
        "publishDiagnostics": { "relatedInformation": true },
        "codeAction": { "codeActionLiteralSupport": true },
        "rename": { "prepareSupport": true }
      },
      "workspace": { "symbol": { "symbolKind": { "valueSet": [1, 12] } } }
    }
  }
}
```

Initialization options:

| Option | Type | Description |
| --- | --- | --- |
| `classpath` | `string[]` | Roots to scan for `.class`/`.j` lookups (defaults to `["sources"]`). Mirrors `--classpath` for the CLI/MCP server. |
| `jvmCliPath` | `string` | Path to `scripts/jvm-cli.js`; used when shelling out for heavyweight transforms. |
| `mcpServerPath` | `string` _(opt)_ | Path to `scripts/mcp-server.js` if the client wants the LSP to delegate operations to the MCP JSON-RPC server. |
| `diagnostics.fixOnSave` | `boolean` _(opt)_ | Planned toggle to auto-apply available fixes during `textDocument/willSaveWaitUntil`. |

## Capabilities

### Currently implemented

```json
{
  "textDocumentSync": 1,
  "documentFormattingProvider": true,
  "definitionProvider": true,
  "completionProvider": { "triggerCharacters": [" ", "\t", ":"] }
}
```

### Planned (already supported by CLI/MCP)

| LSP Feature | Backing Tooling | Notes |
| --- | --- | --- |
| `textDocument/publishDiagnostics` | `jvm-cli lint`, MCP `lintDeadCode` | Diagnostics already include fix diffs; wiring to the LSP is next. |
| `textDocument/codeAction` | MCP `lintDeadCode` | Quick fixes will invoke the same diff-producing command. |
| `textDocument/references` | `workspace.methodCallers` / `workspace.fieldReferences` | Cross references already exist in the workspace metadata. |
| `textDocument/rename` | `renameClass` / `renameMethod` | CLI-tested transforms will provide WorkspaceEdits. |
| `documentSymbol`, `workspaceSymbol` | `KrakatauWorkspace` symbol APIs | Ready to expose. |

## Text Document Flow

1. **Open:** send `textDocument/didOpen` with the full `.j` contents. (`.class` buffers will be handled once diagnostics land; for now open the disassembled `.j` files generated by `jvm-cli disassemble --xref`.)
2. **Change:** send `textDocument/didChange` with full-document sync (the server advertises `TextDocumentSyncKind.Full`).
3. **Close:** send `textDocument/didClose` to release cached buffers and symbol indices.

## Diagnostics (roadmap)

The dead-code passes that power `jvm-cli lint` are already packaged as reusable modules, so LSP diagnostics will surface the same findings. Each diagnostic carries a structured diff and the command needed to apply it:

```json
{
  "uri": "file:///MisplacedCatch.j",
  "diagnostics": [
    {
      "range": { "start": { "line": 5, "character": 0 }, "end": { "line": 7, "character": 12 } },
      "severity": 2,
      "code": "dead-handler",
      "message": "Dead handler/jump detected; handler body can be simplified.",
      "data": {
        "fixCommand": "jvm.applyDeadCodeFix",
        "diff": "@@ ... (unified diff)"
      }
    }
  ]
}
```

Until diagnostics are wired into the LSP, the CLI (`node scripts/jvm-cli.js lint --fix -n`) and MCP server provide the same analysis/fix data.

## Formatting (`textDocument/formatting`)

Formatting reuses the exact pipeline as `node scripts/jvm-cli.js format`:

1. Parse the `.j` buffer via the Krakatau-compatible parser.
2. Assemble and disassemble to normalize stack/local metadata and verify correctness.
3. Emit canonical Jasmin with `unparseDataStructures`.

Indentation preferences from the client are ignored so every tool (CLI, MCP, LSP) produces the same layout (tabs for directives, 4-space instruction columns). Inline `;` comments and standalone comment lines survive the round-trip, so format-on-save is safe even for heavily annotated files.

## Go To Definition (`textDocument/definition`)

The server currently resolves three symbol types:

1. **Method invocations** – recognizes `invokevirtual`, `invokestatic`, `invokeinterface`, and `invokespecial`, matches on `class + name + descriptor`, and searches open documents before lazily loading `.j` siblings relative to the current file or `rootUri`. Plain-text signatures such as `ba.a(ILuf;)V` are also matched anywhere in the document (comments included).
   - Plain-text signatures such as `ba.a(ILuf;)V` are also matched anywhere in the document (comments, data sections, attributes). If the cursor is inside the `Class.method(desc)` token, go-to-definition resolves it just like a real `invoke*` instruction.
2. **Labels** – every label declared within the current `.method … .end method` block is indexed (no requirement that labels start with `L`). References like `goto start` or `ifne loop1` jump to their definitions even if they have obfuscated names.
3. **Class declarations** – `.class public super Foo` lines are parsed so the last identifier (`Foo`) is indexed regardless of how many modifiers precede it.

If a match is found, the server returns a standard `Location` array; otherwise it returns `null` per the LSP spec.

## Code Actions & Commands (roadmap)

Once diagnostics are hooked up, these commands will be surfaced via `workspace/executeCommand` and linked to code actions:

| Command | Purpose |
| --- | --- |
| `jvm.applyDeadCodeFix` | Apply the diff produced by `runDeadCodePass`. |
| `jvm.renameClass` | Rename a class and update references. |
| `jvm.renameMethod` | Rename a method (with descriptor-aware matching) and its call sites. |
| `jvm.disassembleSelection` | Utility command to show bytecode for a highlighted region. |
| `jvm.assembleBuffer` | Assemble an edited Jasmin buffer back into bytecode. |

Because these commands are already part of the MCP server, the LSP simply needs to forward the same JSON payloads.

## Navigation & Metadata Roadmap

| LSP Request | Backing Implementation | Notes |
| --- | --- | --- |
| `textDocument/documentSymbol` | `KrakatauWorkspace.listMethods/fields` | Returns method + field symbols grouped by class. |
| `workspace/symbol` | Workspace class index | Enables cross-project symbol search. |
| `textDocument/references` | `workspace.methodCallers` / `workspace.fieldReferences` | Provides cross references for methods/fields using the classpath-aware workspace. |
| `textDocument/rename` | Rename transforms + purity/throws metadata | Ensures only semantically safe renames are suggested. |

## Completion (`textDocument/completion`)

Two completion modes are available today:

1. **Opcode mnemonics**
   - Triggered automatically after whitespace or immediately following a label colon (`L0:`).
   - Partial mnemonics (e.g., `ico`) filter down to matching opcodes such as `iconst_0`, `iconst_1`, etc.
   - Completions are suppressed inside comments or when the cursor sits in the middle of an operand, so the server only suggests mnemonics where they make sense.
   - Suggestions come directly from the opcode tables used by the assembler/runtime, so every JVM instruction is represented.

2. **Method/Field references**
   - Triggered in three contexts: `Class.member` signatures (even inside comments), `invoke* Method Foo bar ...` operands, and field operands for `getstatic/putstatic/getfield/putfield`.
   - The server merges method metadata from open `.j` documents and any classpath roots specified via `initializationOptions.classpath` (e.g., your workspace + our embedded JRE stubs). That means method names from compiled dependencies show up even if their `.j` sources aren’t open.
   - Field lookups follow the same rules, so `getstatic Field Foo c…` will suggest `counter` (with its descriptor) as soon as a workspace file defines it.
   - Returned items include the descriptor in the `detail` field so editors can display the full signature while inserting only the symbol name.

3. **String constants**
   - Typing `ldc "He` (or `ldc_w`/`ldc2_w`) surfaces constant-pool strings harvested from the open buffers and any classpath roots. Handy for navigating obfuscated string tables without retyping the entire literal.

## Working with `.class` Files

The long-term plan is to allow `.class` buffers directly:

1. Disassemble the opened bytecode using the same logic as `jvm-cli disassemble --xref`.
2. Run diagnostics/formatting on the synthesized Jasmin.
3. Reassemble modifications back into `.class` files before saving.

Until then, pair the LSP with CLI workflows that keep `.j` files synchronized with their `.class` counterparts.

## Testing & Harness

`src/lsp/inProcessHarness.js` spins up the LSP server inside the current process so tests (or client prototypes) can issue requests without sockets or subprocesses. Useful references:

- `test/lspHarness.test.js` – exercises initialization, open/change flows, and synthetic diagnostics.
- `test/lspFormatting.test.js` – verifies formatting preserves comments and spacing.

The harness exposes helpers for `initialize`, `shutdown`, arbitrary requests, and capturing notifications (diagnostics, logs, etc.).

## Summary Checklist for Client Authors

1. Launch `node scripts/lsp-server.js` from the repo root.
2. Send `initialize` with `rootUri` (and `classpath` if you need cross-file lookups outside `sources/`).
3. Use full-document `textDocument/didOpen` + `didChange` notifications.
4. Wire `textDocument/formatting` to your editor’s “format document”.
5. Wire `textDocument/definition` so users can jump to methods, labels, and `.class` declarations.
6. Watch for upcoming diagnostics/code-action support; the request/response shapes documented above will remain stable once enabled.

Following this checklist keeps editor integrations consistent with the CLI, MCP server, and automated tests, while providing a clear path to richer features as they land.
